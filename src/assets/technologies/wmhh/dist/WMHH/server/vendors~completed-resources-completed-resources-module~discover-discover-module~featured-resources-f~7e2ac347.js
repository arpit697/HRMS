exports.ids=[2],exports.modules={MNke:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return ngx_infinite_scroll_InfiniteScrollDirective})),__webpack_require__.d(__webpack_exports__,"b",(function(){return InfiniteScrollModule}));var core=__webpack_require__("8Y7J"),of=__webpack_require__("LRne"),fromEvent=__webpack_require__("xgIS"),mergeMap=__webpack_require__("5+tZ"),map=__webpack_require__("lJxs"),tap=__webpack_require__("vkgz"),filter=__webpack_require__("pLZG"),Subscriber=__webpack_require__("7o/Q"),scheduler_async=__webpack_require__("D0XW"),OuterSubscriber=__webpack_require__("l7GE");__webpack_require__("ZUHj");const defaultThrottleConfig={leading:!0,trailing:!1};OuterSubscriber.a;class ThrottleTimeOperator{constructor(duration,scheduler,leading,trailing){this.duration=duration,this.scheduler=scheduler,this.leading=leading,this.trailing=trailing}call(subscriber,source){return source.subscribe(new throttleTime_ThrottleTimeSubscriber(subscriber,this.duration,this.scheduler,this.leading,this.trailing))}}class throttleTime_ThrottleTimeSubscriber extends Subscriber.a{constructor(destination,duration,scheduler,leading,trailing){super(destination),this.duration=duration,this.scheduler=scheduler,this.leading=leading,this.trailing=trailing,this._hasTrailingValue=!1,this._trailingValue=null}_next(value){this.throttled?this.trailing&&(this._trailingValue=value,this._hasTrailingValue=!0):(this.add(this.throttled=this.scheduler.schedule(dispatchNext,this.duration,{subscriber:this})),this.leading?this.destination.next(value):this.trailing&&(this._trailingValue=value,this._hasTrailingValue=!0))}_complete(){this._hasTrailingValue?(this.destination.next(this._trailingValue),this.destination.complete()):this.destination.complete()}clearThrottle(){const throttled=this.throttled;throttled&&(this.trailing&&this._hasTrailingValue&&(this.destination.next(this._trailingValue),this._trailingValue=null,this._hasTrailingValue=!1),throttled.unsubscribe(),this.remove(throttled),this.throttled=null)}}function dispatchNext(arg){const{subscriber:subscriber}=arg;subscriber.clearThrottle()}function resolveContainerElement(selector,scrollWindow,defaultElement,fromRoot){const hasWindow=window&&!!window.document&&window.document.documentElement;let container=hasWindow&&scrollWindow?window:defaultElement;if(selector){if(container=selector&&hasWindow&&"string"==typeof selector?function findElement(selector,customRoot,fromRoot){return(fromRoot?window.document:customRoot).querySelector(selector)}(selector,defaultElement.nativeElement,fromRoot):selector,!container)throw new Error("ngx-infinite-scroll {resolveContainerElement()}: selector for")}return container}function inputPropChanged(prop){return prop&&!prop.firstChange}const VerticalProps={clientHeight:"clientHeight",offsetHeight:"offsetHeight",scrollHeight:"scrollHeight",pageYOffset:"pageYOffset",offsetTop:"offsetTop",scrollTop:"scrollTop",top:"top"},HorizontalProps={clientHeight:"clientWidth",offsetHeight:"offsetWidth",scrollHeight:"scrollWidth",pageYOffset:"pageXOffset",offsetTop:"offsetLeft",scrollTop:"scrollLeft",top:"left"};class AxisResolver{constructor(vertical=!0){this.vertical=vertical,this.propsMap=vertical?VerticalProps:HorizontalProps}clientHeightKey(){return this.propsMap.clientHeight}offsetHeightKey(){return this.propsMap.offsetHeight}scrollHeightKey(){return this.propsMap.scrollHeight}pageYOffsetKey(){return this.propsMap.pageYOffset}offsetTopKey(){return this.propsMap.offsetTop}scrollTopKey(){return this.propsMap.scrollTop}topKey(){return this.propsMap.top}}function createResolver({windowElement:windowElement,axis:axis}){return function createResolverWithContainer(resolver,windowElement){const container=resolver.isWindow||windowElement&&!windowElement.nativeElement?windowElement:windowElement.nativeElement;return Object.assign(Object.assign({},resolver),{container:container})}({axis:axis,isWindow:isElementWindow(windowElement)},windowElement)}function isElementWindow(windowElement){return["Window","global"].some(obj=>Object.prototype.toString.call(windowElement).includes(obj))}function getDocumentElement(isContainerWindow,windowElement){return isContainerWindow?windowElement.document.documentElement:null}function calculatePoints(element,resolver){const height=function extractHeightForElement({container:container,isWindow:isWindow,axis:axis}){const{offsetHeightKey:offsetHeightKey,clientHeightKey:clientHeightKey}=extractHeightPropKeys(axis);return getElementHeight(container,isWindow,offsetHeightKey,clientHeightKey)}(resolver);return resolver.isWindow?function calculatePointsForWindow(height,element,resolver){const{axis:axis,container:container,isWindow:isWindow}=resolver,{offsetHeightKey:offsetHeightKey,clientHeightKey:clientHeightKey}=extractHeightPropKeys(axis),scrolled=height+getElementPageYOffset(getDocumentElement(isWindow,container),axis,isWindow),nativeElementHeight=getElementHeight(element.nativeElement,isWindow,offsetHeightKey,clientHeightKey),totalToScroll=function getElementOffsetTop(elem,axis,isWindow){const topKey=axis.topKey();if(!elem.getBoundingClientRect)return;return elem.getBoundingClientRect()[topKey]+getElementPageYOffset(elem,axis,isWindow)}(element.nativeElement,axis,isWindow)+nativeElementHeight;return{height:height,scrolled:scrolled,totalToScroll:totalToScroll,isWindow:isWindow}}(height,element,resolver):function calculatePointsForElement(height,element,resolver){const{axis:axis,container:container}=resolver,scrolled=container[axis.scrollTopKey()],totalToScroll=container[axis.scrollHeightKey()];return{height:height,scrolled:scrolled,totalToScroll:totalToScroll,isWindow:!1}}(height,0,resolver)}function extractHeightPropKeys(axis){return{offsetHeightKey:axis.offsetHeightKey(),clientHeightKey:axis.clientHeightKey()}}function getElementHeight(elem,isWindow,offsetHeightKey,clientHeightKey){if(isNaN(elem[offsetHeightKey])){const docElem=getDocumentElement(isWindow,elem);return docElem?docElem[clientHeightKey]:0}return elem[offsetHeightKey]}function getElementPageYOffset(elem,axis,isWindow){const pageYOffset=axis.pageYOffsetKey(),scrollTop=axis.scrollTopKey(),offsetTop=axis.offsetTopKey();return isNaN(window.pageYOffset)?getDocumentElement(isWindow,elem)[scrollTop]:elem.ownerDocument?elem.ownerDocument.defaultView[pageYOffset]:elem[offsetTop]}function shouldFireScrollEvent(container,distance,scrollingDown){let remaining,containerBreakpoint;if(container.totalToScroll<=0)return!1;const scrolledUntilNow=container.isWindow?container.scrolled:container.height+container.scrolled;if(scrollingDown)remaining=(container.totalToScroll-scrolledUntilNow)/container.totalToScroll,containerBreakpoint=distance.down/10;else{const totalHiddenContentHeight=container.scrolled+(container.totalToScroll-scrolledUntilNow);remaining=container.scrolled/totalHiddenContentHeight,containerBreakpoint=distance.up/10}return remaining<=containerBreakpoint}class ScrollState{constructor({totalToScroll:totalToScroll}){this.lastScrollPosition=0,this.lastTotalToScroll=0,this.totalToScroll=0,this.triggered={down:0,up:0},this.totalToScroll=totalToScroll}updateScrollPosition(position){return this.lastScrollPosition=position}updateTotalToScroll(totalToScroll){this.lastTotalToScroll!==totalToScroll&&(this.lastTotalToScroll=this.totalToScroll,this.totalToScroll=totalToScroll)}updateScroll(scrolledUntilNow,totalToScroll){this.updateScrollPosition(scrolledUntilNow),this.updateTotalToScroll(totalToScroll)}updateTriggeredFlag(scroll,isScrollingDown){isScrollingDown?this.triggered.down=scroll:this.triggered.up=scroll}isTriggeredScroll(totalToScroll,isScrollingDown){return isScrollingDown?this.triggered.down===totalToScroll:this.triggered.up===totalToScroll}}function createScroller(config){const{scrollContainer:scrollContainer,scrollWindow:scrollWindow,element:element,fromRoot:fromRoot}=config,resolver=createResolver({axis:new AxisResolver(!config.horizontal),windowElement:resolveContainerElement(scrollContainer,scrollWindow,element,fromRoot)}),scrollState=new ScrollState({totalToScroll:calculatePoints(element,resolver)}),options={container:resolver.container,throttle:config.throttle},distance={up:config.upDistance,down:config.downDistance};return function attachScrollEvent(options){let obs=Object(fromEvent.a)(options.container,"scroll");options.throttle&&(obs=obs.pipe(function throttleTime(duration,scheduler=scheduler_async.a,config=defaultThrottleConfig){return source=>source.lift(new ThrottleTimeOperator(duration,scheduler,config.leading,config.trailing))}(options.throttle)));return obs}(options).pipe(Object(mergeMap.a)(()=>Object(of.a)(calculatePoints(element,resolver))),Object(map.a)(positionStats=>function toInfiniteScrollParams(lastScrollPosition,stats,distance){const{scrollDown:scrollDown,fire:fire}=function getScrollStats(lastScrollPosition,container,distance){const scrollDown=function isScrollingDownwards(lastScrollPosition,container){return lastScrollPosition<container.scrolled}(lastScrollPosition,container);return{fire:shouldFireScrollEvent(container,distance,scrollDown),scrollDown:scrollDown}}(lastScrollPosition,stats,distance);return{scrollDown:scrollDown,fire:fire,stats:stats}}(scrollState.lastScrollPosition,positionStats,distance)),Object(tap.a)(({stats:stats})=>scrollState.updateScroll(stats.scrolled,stats.totalToScroll)),Object(filter.a)(({fire:fire,scrollDown:scrollDown,stats:{totalToScroll:totalToScroll}})=>function shouldTriggerEvents(alwaysCallback,shouldFireScrollEvent,isTriggeredCurrentTotal){return!(!alwaysCallback||!shouldFireScrollEvent)||!(isTriggeredCurrentTotal||!shouldFireScrollEvent)}(config.alwaysCallback,fire,scrollState.isTriggeredScroll(totalToScroll,scrollDown))),Object(tap.a)(({scrollDown:scrollDown,stats:{totalToScroll:totalToScroll}})=>{scrollState.updateTriggeredFlag(totalToScroll,scrollDown)}),Object(map.a)(toInfiniteScrollAction))}const InfiniteScrollActions_DOWN="[NGX_ISE] DOWN",InfiniteScrollActions_UP="[NGX_ISE] UP";function toInfiniteScrollAction(response){const{scrollDown:scrollDown,stats:{scrolled:currentScrollPosition}}=response;return{type:scrollDown?InfiniteScrollActions_DOWN:InfiniteScrollActions_UP,payload:{currentScrollPosition:currentScrollPosition}}}class ngx_infinite_scroll_InfiniteScrollDirective{constructor(element,zone){this.element=element,this.zone=zone,this.scrolled=new core.x,this.scrolledUp=new core.x,this.infiniteScrollDistance=2,this.infiniteScrollUpDistance=1.5,this.infiniteScrollThrottle=150,this.infiniteScrollDisabled=!1,this.infiniteScrollContainer=null,this.scrollWindow=!0,this.immediateCheck=!1,this.horizontal=!1,this.alwaysCallback=!1,this.fromRoot=!1}ngAfterViewInit(){this.infiniteScrollDisabled||this.setup()}ngOnChanges({infiniteScrollContainer:infiniteScrollContainer,infiniteScrollDisabled:infiniteScrollDisabled,infiniteScrollDistance:infiniteScrollDistance}){const containerChanged=inputPropChanged(infiniteScrollContainer),disabledChanged=inputPropChanged(infiniteScrollDisabled),distanceChanged=inputPropChanged(infiniteScrollDistance),shouldSetup=!disabledChanged&&!this.infiniteScrollDisabled||disabledChanged&&!infiniteScrollDisabled.currentValue||distanceChanged;(containerChanged||disabledChanged||distanceChanged)&&(this.destroyScroller(),shouldSetup&&this.setup())}setup(){(function hasWindowDefined(){return"undefined"!=typeof window})()&&this.zone.runOutsideAngular(()=>{this.disposeScroller=createScroller({fromRoot:this.fromRoot,alwaysCallback:this.alwaysCallback,disable:this.infiniteScrollDisabled,downDistance:this.infiniteScrollDistance,element:this.element,horizontal:this.horizontal,scrollContainer:this.infiniteScrollContainer,scrollWindow:this.scrollWindow,throttle:this.infiniteScrollThrottle,upDistance:this.infiniteScrollUpDistance}).subscribe(payload=>this.zone.run(()=>this.handleOnScroll(payload)))})}handleOnScroll({type:type,payload:payload}){switch(type){case InfiniteScrollActions_DOWN:return this.scrolled.emit(payload);case InfiniteScrollActions_UP:return this.scrolledUp.emit(payload);default:return}}ngOnDestroy(){this.destroyScroller()}destroyScroller(){this.disposeScroller&&this.disposeScroller.unsubscribe()}}ngx_infinite_scroll_InfiniteScrollDirective.\u0275fac=function InfiniteScrollDirective_Factory(t){return new(t||ngx_infinite_scroll_InfiniteScrollDirective)(core.Lc(core.v),core.Lc(core.Q))},ngx_infinite_scroll_InfiniteScrollDirective.\u0275dir=core.Gc({type:ngx_infinite_scroll_InfiniteScrollDirective,selectors:[["","infiniteScroll",""],["","infinite-scroll",""],["","data-infinite-scroll",""]],inputs:{infiniteScrollDistance:"infiniteScrollDistance",infiniteScrollUpDistance:"infiniteScrollUpDistance",infiniteScrollThrottle:"infiniteScrollThrottle",infiniteScrollDisabled:"infiniteScrollDisabled",infiniteScrollContainer:"infiniteScrollContainer",scrollWindow:"scrollWindow",immediateCheck:"immediateCheck",horizontal:"horizontal",alwaysCallback:"alwaysCallback",fromRoot:"fromRoot"},outputs:{scrolled:"scrolled",scrolledUp:"scrolledUp"},features:[core.yc]}),ngx_infinite_scroll_InfiniteScrollDirective.ctorParameters=()=>[{type:core.v},{type:core.Q}],ngx_infinite_scroll_InfiniteScrollDirective.propDecorators={scrolled:[{type:core.S}],scrolledUp:[{type:core.S}],infiniteScrollDistance:[{type:core.G}],infiniteScrollUpDistance:[{type:core.G}],infiniteScrollThrottle:[{type:core.G}],infiniteScrollDisabled:[{type:core.G}],infiniteScrollContainer:[{type:core.G}],scrollWindow:[{type:core.G}],immediateCheck:[{type:core.G}],horizontal:[{type:core.G}],alwaysCallback:[{type:core.G}],fromRoot:[{type:core.G}]};class InfiniteScrollModule{}InfiniteScrollModule.\u0275mod=core.Jc({type:InfiniteScrollModule}),InfiniteScrollModule.\u0275inj=core.Ic({factory:function InfiniteScrollModule_Factory(t){return new(t||InfiniteScrollModule)},providers:[],imports:[[]]})}};